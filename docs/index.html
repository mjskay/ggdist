<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tidy Data for MCMC/Bayesian Samplers • tidybayes</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="pkgdown.css" rel="stylesheet">
<script src="jquery.sticky-kit.min.js"></script><script src="pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">tidybayes</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="/index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="articles/tidybayes.html">Get Started</a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="articles/tidy-rstanarm.html">Extracting tidy samples from rstanarm</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mjskay/tidybayes">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    

    
    
<div class="contents">

<p><em>Matthew Kay, University of Michigan, <a href="mailto:mjskay@umich.edu">mjskay@umich.edu</a></em></p>
<p><a href="http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html">Tidy</a> data frames (one observation per row) are particularly convenient for use in a variety of R data manipulation and visualization packages. However, when using MCMC / Bayesian samplers like JAGS or Stan in R, we often have to translate this data into a form the sampler understands, and then after running the model, translate the resulting sample into a more tidy format for use with other R functions. <code>tidybayes</code> aims to simplify these two common (often tedious) operations:</p>
<ul>
<li><p><strong>Composing data</strong> for use with the sampler. This often means translating data from a <code>data.frame</code> into a <code>list</code> , making sure <code>factors</code> are encoded as numerical data, adding variables to store the length of indices, etc. This package helps automate these operations using the <code>compose_data</code> function, which automatically handles data types like <code>numeric</code>, <code>logical</code>, <code>factor</code>, and <code>ordinal</code>, and allows easy extensions for converting other datatypes into a format the sampler understands by providing your own implementation of the generic <code>as_data_list</code>.</p></li>
<li><p><strong>Extracting tidy samples</strong> from the sampler. This often means extracting indices from parameters with names like <code>"b[1,1]"</code>, <code>"b[1,2]"</code> into separate columns of a data frame, like <code>i = c(1,1,..)</code> and <code>j = c(1,2,...)</code>. More tediously, sometimes these indices actually correspond to levels of a factor in the original data; e.g. <code>"x[1]"</code> might correspond to a value of <code>x</code> for the first level of some factor. We provide several straightforward ways to convert samples of a variable with indices into useful long-format (“<a href="http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html">tidy</a>”) data frames, with automatic back-conversion of common data types (factors, logicals) using the <code>spread_samples</code> and <code>gather_sampels</code> functions, including automatic recovery of factor levels corresponding to variable indices. In most cases this kind of long-format data is much easier to use with other data-manipulation and plotting packages (e.g., <code>dplyr</code>, <code>tidyr</code>, <code>ggplot2</code>) than the format provided by default from the sampler.</p></li>
</ul>
<p><code>tidybayes</code> also provides some additional functionality for data manipulation and visualization tasks common to many models:</p>
<ul>
<li><p><strong>Extracting tidy fits and predictions</strong> from models. For models like those provided by <code>rstanarm</code> and <code>brms</code>, <code>tidybayes</code> provides a tidy analog of the <code>fitted</code> and <code>predict</code> functions, called <code>add_fitted_samples</code> and <code>add_predicted_samples</code>. These functions are modeled after the <code><a href="http://www.rdocumentation.org/packages/modelr/topics/add_predictions">modelr::add_predictions</a></code> function, and turn a grid of predictions into a long-format data frame of samples from either the fits or predictions from a model. These functions make it straightforward to generate arbitrary fit lines from a model.</p></li>
<li><p><strong>Summarizing posterior distributions</strong> from models. The <code>point_interval</code> family of functions (<code>mean_qi</code>, <code>median_qi</code>, <code>mode_hdi</code>, etc) are methods for generating estimates and intervals that are designed with tidy workflows in mind. They can generate estimates plus an arbitrary number of probability intervals <em>from</em> tidy data frames of samples, they <em>return</em> tidy data frames, and they <strong>respect data frame groups</strong>.</p></li>
<li>
<p><strong>Visualizing posteriors</strong>, which when many estimates are involved can be done succinctly using <strong>eye plots</strong> (aka raindrop plots or violin plots). Eye plots are a compact representation of posterior densities that combines credible intervals and point estimates with a symmetric visualization of density, making for straightforward and compact comparison of many data points. The <code>geom_eye</code> and <code>geom_eyeh</code> functions provide a convenient way to generate eye plots using <code>ggplot2</code>. If you prefer intervals plus densities (instead of violins), the <strong>half-eye plot</strong> is also easily constructing using <code>geom_halfeyeh</code>.</p>
<p>The focus on tidy data suitable for use with <code>ggplot</code> means that existing <code>geom</code>s (like <code>geom_pointrange</code> and <code>geom_linerange</code>) can also be used easily to construct custom plots. Modified versions of those vanilla geoms are also provided (e.g., <code>geom_pointinterval</code> and <code>geom_pointintervalh</code>) with sensible defaults for tasks like plotting multiple intervals per estimate.</p>
</li>
<li><p><strong>Comparing a variable across levels of a factor</strong>, which often means first generating pairs of levels of a factor (according to some desired set of comparisons) and then computing a function over the value of the comparison variable for those pairs of levels. Assuming your data is in the format returned by <code>spread_samples</code>, the <code>compare_levels</code> function allows comparison across levels to be made easily.</p></li>
</ul>
<p>Finally, <code>tidybayes</code> aims to fit into common workflows through compatibility with other packages:</p>
<ul>
<li><p><strong>Compatibility with other tidy packages</strong>. Default column names in the output have also been chosen for compatibility with <code><a href="http://www.rdocumentation.org/packages/broom/topics/tidy">broom::tidy</a></code>, which makes comparison with estimates from non-Bayesian models straightforward.</p></li>
<li><p><strong>Compatibility with non-tidy packages</strong>. The <code>unspread_samples</code> and <code>ungather_samples</code> functions invert <code>spread_samples</code> and <code>gather_samples</code>, aiding compatiblity with other Bayesian plotting packages (notably <code>bayesplot</code>).</p></li>
</ul>
<div id="supported-model-types" class="section level2">
<h2 class="hasAnchor">
<a href="#supported-model-types" class="anchor"></a>Supported model types</h2>
<p><code>tidybayes</code> aims to support a variety of models with a uniform interface. Currently supported models include <a href="https://cran.r-project.org/package=rstan">rstan</a>, <a href="https://cran.r-project.org/package=coda">coda::mcmc and coda::mcmc.list</a>, <a href="https://cran.r-project.org/package=runjags">runjags</a>, <a href="https://cran.r-project.org/package=rstanarm">rstanarm</a>, <a href="https://cran.r-project.org/package=brms">brms</a>, <a href="https://cran.r-project.org/package=MCMCglmm">MCMCglmm</a>, and anything with its own <code>as.mcmc.list</code> implementation. If you install the <a href="https://github.com/mjskay/tidybayes.rethinking">tidybayes.rethinking</a> package, models from the <a href="https://github.com/rmcelreath/rethinking">rethinking</a> package are also supported.</p>
</div>
<div id="installation" class="section level2">
<h2 class="hasAnchor">
<a href="#installation" class="anchor"></a>Installation</h2>
<p>You can install the latest development version from GitHub with these R commands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">"devtools"</span>)
devtools::<span class="kw">install_github</span>(<span class="st">"mjskay/tidybayes"</span>)</code></pre></div>
</div>
<div id="examples" class="section level2">
<h2 class="hasAnchor">
<a href="#examples" class="anchor"></a>Examples</h2>
<p>This example shows the use of tidybayes with the Stan modeling language; however, tidybayes supports many other samplers and models, such as JAGS, brm, rstanarm, and (theoretically) any model type supported by <code><a href="http://www.rdocumentation.org/packages/coda/topics/mcmc.list">coda::as.mcmc.list</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)
<span class="kw">library</span>(dplyr)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(ggstance)
<span class="kw">library</span>(rstan)
<span class="kw">library</span>(tidybayes)
<span class="kw">library</span>(lsmeans)
<span class="kw">library</span>(broom)
<span class="kw">library</span>(brms)
<span class="kw">library</span>(modelr)
<span class="kw">library</span>(forcats)</code></pre></div>
<p>Imagine this dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">5</span>)
n =<span class="st"> </span><span class="dv">10</span>
n_condition =<span class="st"> </span><span class="dv">5</span>
ABC =
<span class="st">  </span><span class="kw">data_frame</span>(
    <span class="dt">condition =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>,<span class="st">"D"</span>,<span class="st">"E"</span>), n),
    <span class="dt">response =</span> <span class="kw">rnorm</span>(n *<span class="st"> </span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,-<span class="dv">1</span>), <span class="fl">0.5</span>)
  )

ABC %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> response, <span class="dt">y =</span> condition)) +
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="fl">0.5</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">"condition"</span>)</code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" width="672"></p>
<p>A hierarchical model of this data might estimate an overall mean across the conditions (<code>overall_mean</code>), the standard deviation of the condition means (<code>condition_mean_sd</code>), the mean within each condition (<code>condition_mean[condition]</code>) and the standard deviation of the responses given a condition mean (<code>response_sd</code>):</p>
<pre class="stan"><code>data {
  int&lt;lower=1&gt; n;
  int&lt;lower=1&gt; n_condition;
  int&lt;lower=1, upper=n_condition&gt; condition[n];
  real response[n];
}
parameters {
  real overall_mean;
  vector[n_condition] condition_zoffset;
  real&lt;lower=0&gt; response_sd;
  real&lt;lower=0&gt; condition_mean_sd;
}
transformed parameters {
  vector[n_condition] condition_mean;
  condition_mean = overall_mean + condition_zoffset * condition_mean_sd;
}
model {
  response_sd ~ cauchy(0, 1);         # =&gt; half-cauchy(0, 1)
  condition_mean_sd ~ cauchy(0, 1);   # =&gt; half-cauchy(0, 1)
  overall_mean ~ normal(0, 5);
  condition_zoffset ~ normal(0, 1);   # =&gt; condition_mean ~ normal(overall_mean, condition_mean_sd)
  for (i in 1:n) {
    response[i] ~ normal(condition_mean[condition[i]], response_sd);
  }
}</code></pre>
<div id="composing-data-for-input-to-model-compose_data" class="section level3">
<h3 class="hasAnchor">
<a href="#composing-data-for-input-to-model-compose_data" class="anchor"></a>Composing data for input to model: <code>compose_data</code>
</h3>
<p>We have compiled and loaded this model into the variable <code>ABC_stan</code>. Rather than munge the data into a format Stan likes ourselves, we will use the <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/compose_data">tidybayes::compose_data</a></code> function, which takes our <code>ABC</code> data frame and automatically generates a list of the following elements:</p>
<ul>
<li>
<code>n</code>: number of observations in the data frame</li>
<li>
<code>n_condition</code>: number of levels of the condition factor</li>
<li>
<code>condition</code>: a vector of integers indicating the condition of each observation</li>
<li>
<code>response</code>: a vector of observations</li>
</ul>
<p>So we can skip right to modeling:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="kw">sampling</span>(ABC_stan, <span class="dt">data =</span> <span class="kw"><a href="reference/compose_data.html">compose_data</a></span>(ABC), <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">adapt_delta=</span><span class="fl">0.99</span>))</code></pre></div>
</div>
<div id="getting-tidy-samples-from-the-model-spread_samples" class="section level3">
<h3 class="hasAnchor">
<a href="#getting-tidy-samples-from-the-model-spread_samples" class="anchor"></a>Getting tidy samples from the model: <code>spread_samples</code>
</h3>
<p>We decorate the fitted model using <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/recover_types">tidybayes::recover_types</a></code>, which will ensure that numeric indices (like <code>condition</code>) are back-translated back into factors when we extract data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&lt;&gt;%<span class="st"> </span><span class="kw"><a href="reference/recover_types.html">recover_types</a></span>(ABC)</code></pre></div>
<p>Now we can extract parameters of interest using <code>spread_samples</code>, which automatically parses indices, converts them back into their original format, and turns them into data frame columns. This function accepts a symbolic specification of Stan variables using the same syntax you would to index columns in Stan. For example, we can extract the condition means and the residual standard deviation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/spread_samples.html">spread_samples</a></span>(condition_mean[condition], response_sd) %&gt;%
<span class="st">  </span><span class="kw">head</span>(<span class="dv">15</span>)  <span class="co"># just show the first few rows</span></code></pre></div>
<pre><code>## # A tibble: 15 x 5
## # Groups:   condition [5]
##    .chain .iteration condition condition_mean response_sd
##     &lt;int&gt;      &lt;int&gt;    &lt;fctr&gt;          &lt;dbl&gt;       &lt;dbl&gt;
##  1      1          1         A     -0.1206604   0.6131074
##  2      1          1         B      1.0043807   0.6131074
##  3      1          1         C      1.5011137   0.6131074
##  4      1          1         D      1.1089315   0.6131074
##  5      1          1         E     -1.1163084   0.6131074
##  6      1          2         A      0.2778306   0.4997878
##  7      1          2         B      0.7552125   0.4997878
##  8      1          2         C      1.8340128   0.4997878
##  9      1          2         D      0.7040865   0.4997878
## 10      1          2         E     -1.1510277   0.4997878
## 11      1          3         A      0.0078763   0.4952302
## 12      1          3         B      1.2779759   0.4952302
## 13      1          3         C      2.0680137   0.4952302
## 14      1          3         D      1.3867664   0.4952302
## 15      1          3         E     -0.7519878   0.4952302</code></pre>
<p>The condition numbers are automatically turned back into text (“A”, “B”, “C”, …) and split into their own column. A long-format data frame is returned with a row for every iteration <span class="math inline">\(\times\)</span> every combination of indices across all variables given to <code>spread_samples</code>; for example, because <code>response_sd</code> here is not indexed by <code>condition</code>, within the same iteration it has the same value for each row corresponding to a different <code>condition</code> (some other formats supported by <code>tidybayes</code> are discussed in <code><a href="articles/tidybayes.html">vignette("tidybayes")</a></code>; in particular, the format returned by <code>gather_samples</code>).</p>
</div>
<div id="plotting-posteriors-as-eye-plots-geom_eye-geom_eyeh" class="section level3">
<h3 class="hasAnchor">
<a href="#plotting-posteriors-as-eye-plots-geom_eye-geom_eyeh" class="anchor"></a>Plotting posteriors as eye plots: <code>geom_eye</code> / <code>geom_eyeh</code>
</h3>
<p>Automatic splitting of indices into columns makes it easy to plot the condition means here. We will employ the <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/geom_eyeh">tidybayes::geom_eyeh</a></code> geom (horizontal version of <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/geom_eye">tidybayes::geom_eye</a></code>), which combines a violin plot of the posterior density, mean, and 95% quantile interval to give an “eye plot” of the posterior. The point and interval types are customizable using the <code>point_interval</code> family of functions. A “half-eye” plot (non-mirrored density) is also available as <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/geom_halfeyeh">tidybayes::geom_halfeyeh</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/spread_samples.html">spread_samples</a></span>(condition_mean[condition]) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> condition_mean, <span class="dt">y =</span> condition)) +
<span class="st">  </span><span class="kw"><a href="reference/geom_eyeh.html">geom_eyeh</a></span>()</code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" width="672"></p>
</div>
<div id="model-comparison-via-compatibility-with-broom" class="section level3">
<h3 class="hasAnchor">
<a href="#model-comparison-via-compatibility-with-broom" class="anchor"></a>Model comparison via compatibility with <code>broom</code>
</h3>
<p>The output of the <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/point_interval">tidybayes::mean_qi</a></code> function (and other <code>point_interval</code> functions) is compatible with <code><a href="http://www.rdocumentation.org/packages/broom/topics/tidy">broom::tidy</a></code>, so we can compare parameter estimates easily to models supported by <code>broom</code>.</p>
<p>For example, let’s compare to ordinary least squares (OLS) regression:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linear_estimates =<span class="st"> </span>
<span class="st">  </span><span class="kw">lm</span>(response ~<span class="st"> </span>condition, <span class="dt">data =</span> ABC) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">lsmeans</span>(~<span class="st"> </span>condition) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">tidy</span>() %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="st">"OLS"</span>)
linear_estimates</code></pre></div>
<pre><code>##   condition   estimate std.error df   conf.low  conf.high model
## 1         A  0.1815842  0.173236 45 -0.1673310  0.5304993   OLS
## 2         B  1.0142144  0.173236 45  0.6652993  1.3631296   OLS
## 3         C  1.8745839  0.173236 45  1.5256687  2.2234990   OLS
## 4         D  1.0271794  0.173236 45  0.6782642  1.3760946   OLS
## 5         E -0.9352260  0.173236 45 -1.2841411 -0.5863108   OLS</code></pre>
<p>The output from <code>mean_qi</code> when given a single parameter uses <code>conf.low</code> and <code>conf.high</code> for interval names so that it lines up with <code>tidy</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bayes_estimates =<span class="st"> </span>m %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/spread_samples.html">spread_samples</a></span>(condition_mean[condition]) %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/point_interval.html">mean_qi</a></span>(<span class="dt">estimate =</span> condition_mean) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="st">"Bayes"</span>)
bayes_estimates</code></pre></div>
<pre><code>## # A tibble: 5 x 6
## # Groups:   condition [5]
##   condition   estimate   conf.low  conf.high .prob model
##      &lt;fctr&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
## 1         A  0.1968434 -0.1427452  0.5482592  0.95 Bayes
## 2         B  1.0075166  0.6539753  1.3588999  0.95 Bayes
## 3         C  1.8420086  1.4953866  2.1836275  0.95 Bayes
## 4         D  1.0153748  0.6710544  1.3494475  0.95 Bayes
## 5         E -0.8916102 -1.2320089 -0.5412994  0.95 Bayes</code></pre>
<p>This makes it easy to bind the two estimates together and plot them:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bind_rows</span>(linear_estimates, bayes_estimates) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> condition, <span class="dt">x =</span> estimate, <span class="dt">xmin =</span> conf.low, <span class="dt">xmax =</span> conf.high, <span class="dt">color =</span> model)) +
<span class="st">  </span><span class="kw">geom_pointrangeh</span>(<span class="dt">position =</span> <span class="kw">position_dodgev</span>(<span class="dt">height =</span> .<span class="dv">3</span>))</code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p>Shrinkage towards the overall mean is visible in the Bayesian estimates.</p>
<p>Comptability with <code><a href="http://www.rdocumentation.org/packages/broom/topics/tidy">broom::tidy</a></code> also gives compatibility with <code><a href="http://www.rdocumentation.org/packages/dotwhisker/topics/dwplot">dotwhisker::dwplot</a></code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bind_rows</span>(linear_estimates, bayes_estimates) %&gt;%
<span class="st">  </span><span class="kw">rename</span>(<span class="dt">term =</span> condition) %&gt;%
<span class="st">  </span>dotwhisker::<span class="kw">dwplot</span>()</code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" width="672"></p>
</div>
<div id="posterior-prediction-and-complex-custom-plots" class="section level3">
<h3 class="hasAnchor">
<a href="#posterior-prediction-and-complex-custom-plots" class="anchor"></a>Posterior prediction and complex custom plots</h3>
<p>The tidy data format returned by <code>spread_samples</code> also facilitates additional computation on parameters followed by the construction of more complex custom plots. For example, we can generate posterior predictions easily, and use the <code>.prob</code> argument of <code>mean_qih</code> to generate several intervals from the posterior predictions, then plot them alongside parameter estimates and the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/spread_samples.html">spread_samples</a></span>(condition_mean[condition], response_sd) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pred =</span> <span class="kw">rnorm</span>(<span class="kw">n</span>(), condition_mean, response_sd)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> condition)) +
<span class="st">  </span>
<span class="st">  </span><span class="co"># posterior predictive intervals</span>
<span class="st">  </span><span class="kw">stat_summaryh</span>(<span class="kw">aes</span>(<span class="dt">x =</span> pred, <span class="dt">color =</span> <span class="kw">ordered</span>(-...prob..)), <span class="dt">size =</span> <span class="dv">4</span>,
    <span class="dt">fun.data =</span> mean_qih, <span class="dt">fun.args =</span> <span class="kw">list</span>(<span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>)), <span class="dt">geom =</span> <span class="st">"linerangeh"</span>) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="dt">guide =</span> <span class="ot">FALSE</span>) +
<span class="st">  </span>
<span class="st">  </span><span class="co"># mean and qi of condition mean</span>
<span class="st">  </span><span class="kw">stat_summaryh</span>(<span class="kw">aes</span>(<span class="dt">x =</span> condition_mean), <span class="dt">fun.data =</span> mean_qih, <span class="dt">position =</span> <span class="kw">position_nudge</span>(<span class="dt">y =</span> -<span class="fl">0.2</span>)) +
<span class="st">  </span>
<span class="st">  </span><span class="co"># data</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">x =</span> response), <span class="dt">data =</span> ABC)</code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-12-1.png" width="672"></p>
<p>This plot shows 95% quantile credible intervals of posterior mean for each condition (point + black line); 95%, 80%, and 50% posterior predictive intervals (blue); and the data.</p>
<div id="fit-curves" class="section level4">
<h4 class="hasAnchor">
<a href="#fit-curves" class="anchor"></a>Fit curves</h4>
<p>For models that support it (like <code>rstanarm</code> and <code>brms</code> models), We can also use the <code>add_fitted_samples</code> or <code>add_predicted_samples</code> functions to generate posterior fits or predictions. Combined with the functions from the <code>modelr</code> package, this makes it easy to generate fit curves.</p>
<p>Let’s fit a slightly naive model to miles per gallon versus horsepower in the <code>mtcars</code> dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_mpg =<span class="st"> </span><span class="kw">brm</span>(mpg ~<span class="st"> </span><span class="kw">log</span>(hp), <span class="dt">data =</span> mtcars, <span class="dt">family =</span> lognormal)</code></pre></div>
<p>Now we will use <code><a href="http://www.rdocumentation.org/packages/modelr/topics/data_grid">modelr::data_grid</a></code> plus <code><a href="http://www.rdocumentation.org/packages/tidybayes/topics/add_predicted_samples">tidybayes::add_predicted_samples</a></code> to generate a fit curve with multiple probability bands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">data_grid</span>(<span class="dt">hp =</span> <span class="kw">seq_range</span>(hp, <span class="dt">n =</span> <span class="dv">100</span>)) %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/add_predicted_samples.html">add_predicted_samples</a></span>(m_mpg) %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/point_interval.html">median_qi</a></span>(<span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">99</span>, .<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> hp)) +
<span class="st">  </span><span class="kw"><a href="reference/geom_lineribbon.html">geom_lineribbon</a></span>(<span class="kw">aes</span>(<span class="dt">y =</span> pred)) +
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> mpg), <span class="dt">data =</span> mtcars) +
<span class="st">  </span><span class="kw">scale_fill_brewer</span>()</code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<p><code><a href="reference/geom_lineribbon.html">geom_lineribbon(aes(y = pred))</a></code> in the above code is a shortcut for something like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">geom_ribbon</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high, <span class="dt">fill =</span> forcats::<span class="kw">fct_rev</span>(<span class="kw">ordered</span>(.prob)))) +
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">y =</span> pred), <span class="dt">color =</span> <span class="st">"red"</span>, <span class="dt">size =</span> <span class="fl">1.25</span>)</code></pre></div>
<p>Because this is all tidy data, if you wanted to build a model with interactions among different categorical variables (say a different curve for automatic and manula transmissions), you can easily generate predictions faceted over that variable (say, different curves for different transmission types). Then you could use the existing faceting features built in to ggplot to plot them.</p>
<p>Such a model might be:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_mpg_am =<span class="st"> </span><span class="kw">brm</span>(mpg ~<span class="st"> </span><span class="kw">log</span>(hp)*am, <span class="dt">data =</span> mtcars, <span class="dt">family =</span> lognormal)</code></pre></div>
<p>Then we can generate and plot predictions as before (differences from above are highlighted as comments):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars %&gt;%
<span class="st">  </span><span class="kw">data_grid</span>(<span class="dt">hp =</span> <span class="kw">seq_range</span>(hp, <span class="dt">n =</span> <span class="dv">100</span>), am) %&gt;%<span class="st">    </span><span class="co"># add am to the prediction grid</span>
<span class="st">  </span><span class="kw"><a href="reference/add_predicted_samples.html">add_predicted_samples</a></span>(m_mpg_am) %&gt;%
<span class="st">  </span><span class="kw"><a href="reference/point_interval.html">median_qi</a></span>(<span class="dt">.prob =</span> <span class="kw">c</span>(.<span class="dv">99</span>, .<span class="dv">95</span>, .<span class="dv">8</span>, .<span class="dv">5</span>)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> hp)) +
<span class="st">  </span><span class="kw"><a href="reference/geom_lineribbon.html">geom_lineribbon</a></span>(<span class="kw">aes</span>(<span class="dt">y =</span> pred)) +
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> mpg), <span class="dt">data =</span> mtcars) +
<span class="st">  </span><span class="kw">scale_fill_brewer</span>() +
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> </span>am)                                  <span class="co"># facet by am</span></code></pre></div>
<p><img src="index_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p>See <code><a href="articles/tidybayes.html">vignette("tidybayes")</a></code> for a variety of additional examples and more explanation of how it works.</p>
</div>
</div>
</div>
<div id="feedback-and-issues" class="section level2">
<h2 class="hasAnchor">
<a href="#feedback-and-issues" class="anchor"></a>Feedback and issues</h2>
<p>I welcome feedback, suggestions, and issues! Contact me at <a href="mailto:mjskay@umich.edu">mjskay@umich.edu</a>. If you have found a bug, please file it <a href="https://github.com/mjskay/tidybayes/issues/new">here</a> with minimal code to reproduce the issue.</p>
<p><code>tidybayes</code> grew out of helper functions I wrote to make my own analysis pipelines tidier. Over time it has expanded to cover more use cases I have encountered, but I would love to make it cover more!</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2 class="hasAnchor">
<a href="#sidebar" class="anchor"></a>Links</h2>
<ul class="list-unstyled">
<li>Browse source code at <br><a href="https://github.com/mjskay/tidybayes">https://​github.com/​mjskay/​tidybayes</a>
</li>
<li>Report a bug at <br><a href="https://github.com/mjskay/tidybayes/issues/new">https://​github.com/​mjskay/​tidybayes/​issues/​new</a>
</li>
</ul>
<h2>License</h2>
<p>GPL (&gt;= 3)</p>
<h2>Citation</h2>
<ul class="list-unstyled">
<li><a href="authors.html">Citing tidybayes</a></li>
</ul>
<h2>Developers</h2>
<ul class="list-unstyled">
<li>Matthew Kay <br><small class="roles"> Author, maintainer </small> </li>
</ul>
<h2>Dev status</h2>
<ul class="list-unstyled">
<li><a href="https://travis-ci.org/mjskay/tidybayes"><img src="https://travis-ci.org/mjskay/tidybayes.png?branch=master" alt="Build Status"></a></li>
</ul>
</div>

</div>


      <footer><div class="copyright">
  <p>Developed by Matthew Kay.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
