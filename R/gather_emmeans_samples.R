# gather_emmeans_samples (formerly gather_lsmeans_samples)
#
# Author: mjskay
###############################################################################


# DEPRECATED NAMES FOR gather_emmeans_samples
#' @rdname tidybayes-deprecated
#' @format NULL
#' @usage NULL
#' @export
gather_lsmeans_samples = function(...) {
  .Deprecated("gather_emmeans_samples")  # nocov
  gather_emmeans_samples(...)            # nocov
}


#' Extract tidy samples of estimated marginal means (emmeans/lsmeans) from a Bayesian model fit
#'
#' Extract samples from the result of a call to \code{\link[emmeans]{emmeans}} (formerly \code{lsmeans})
#' or \code{\link[emmeans]{ref_grid}} applied to a Bayesian model.
#'
#' \code{\link[emmeans]{emmeans}} provides a convenient syntax for generating marginal estimates from a model,
#' and can be applied to various Bayesian models, like \code{\link[rstanarm]{stanreg-objects}} and
#' \code{\link[MCMCglmm]{MCMCglmm}}. Given a \code{\link[emmeans]{ref_grid}} object as returned by functions like
#' \code{\link[emmeans]{ref_grid}} or \code{\link[emmeans]{emmeans}} applied to a Bayesian model,
#' \code{gather_emmeans_samples} returns a tidy format data frame of samples from
#' the marginal posterior distributions generated by \code{\link[emmeans]{emmeans}}.
#'
#' @param object An \code{emmGrid} object such as returned by
#' \code{\link[emmeans]{ref_grid}} or \code{\link[emmeans]{emmeans}}.
#'
#' @return A data frame of tidy samples. The columns of the reference grid are returned as-is, with an
#' additional column called \code{estimate} containing samples from the marginal estimates (the name \code{estimate} is
#' used for compatibility with \code{\link{gather_samples}} and \code{\link[broom]{tidy}}). The resulting data
#' frame is grouped by the columns from the reference grid to make use of summary functions like
#' \code{\link{point_interval}} straightforward.
#'
#' @author Matthew Kay
#' @seealso \code{\link[emmeans]{emmeans}}
#' @keywords manip
#' @examples
#'
#' library(dplyr)
#' library(magrittr)
#' library(rstanarm)
#' library(emmeans)
#'
#' # Here's an example dataset with a categorical predictor (`condition`) with several levels:
#' set.seed(5)
#' n = 10
#' n_condition = 5
#' ABC =
#'   data_frame(
#'     condition = rep(c("A","B","C","D","E"), n),
#'     response = rnorm(n * 5, c(0,1,2,1,-1), 0.5)
#'   )
#'
#' m = stan_glm(response ~ condition, data = ABC,
#'   # 1 chain / few iterations just so example runs quickly
#'   # do not use in practice
#'   chains = 1, iter = 500)
#'
#' # Once we've fit the model, we can use emmeans() (and functions
#' # from that package) to get whatever marginal estimates we want.
#' # For example, we can get estimated marginal means by condition:
#' m %>%
#'   emmeans(~ condition) %>%
#'   gather_emmeans_samples() %>%
#'   mean_qi()
#'
#' # or we could get pairwise differences:
#' m %>%
#'   emmeans( ~ condition) %>%
#'   contrast(method = "pairwise") %>%
#'   gather_emmeans_samples() %>%
#'   mean_qi()
#'
#' # see the documentation of emmeans() for more examples of types of
#' # contrasts supported by that packge.
#'
#' @importFrom magrittr %>%
#' @importFrom purrr map_dfr
#' @importFrom tibble as_tibble
#' @importFrom rlang syms
#' @export
gather_emmeans_samples = function(object) {
  grid = as_tibble(object@grid)

  # this matrix will have n_iterations rows and nrow(grid) columns,
  # where mat[, i] is the posterior estimate for grid[i, ]
  mat = object@post.beta %*% t(object@linfct)

  samples = map_dfr(seq_len(nrow(grid)), function(i) {
    post = as.vector(mat[, i])
    if (!is.null(offset <- object@grid[i, ".offset."])) {
      post = post + offset
    }
    cbind(
      grid[i, ],
      .chain = as.integer(NA),
      .iteration = seq_along(post),
      estimate = post
    )
  })

  samples[, setdiff(names(samples), c(".wgt.", ".offset."))] %>%
    as_tibble() %>%
    group_by(!!!syms(setdiff(names(.), c(".chain", ".iteration", "estimate"))))
}
